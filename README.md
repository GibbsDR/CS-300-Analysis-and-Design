# CS-300-Analysis-and-Design
What was the problem you were solving in the projects for this course?

In Project One, I analyzed the run-time and memory usage of different data structures to understand how their performance changes with different operations and workloads. In Project Two, I built a program that reads a list of courses from a file, stores them in a data structure, and then prints the courses in alphanumeric order. The core problem across both projects was selecting the right data structure and applying algorithmic reasoning to produce efficient, organized output.

How did you approach the problem?

I approached the projects by comparing different data structures, such as vectors, hash tables, and binary search trees. Understanding data structures was important because the efficiency of searching, inserting, and sorting directly affects the overall performance of software systems. Choosing the best structure required evaluating time complexity and considering how the program needed to behave.

How did you overcome any roadblocks you encountered?

When I ran into challenges—such as debugging file-read issues, sorting logic, or ensuring the data structure produced the correct output—I used incremental testing, printed intermediate values, and referenced course materials. I also rechecked my algorithm logic and adjusted my approach when something didn’t produce the expected results.

How has your work on this project expanded your approach to designing software?

These projects strengthened my understanding of how much the choice of data structure shapes the architecture of a program. Instead of jumping straight into coding, I now evaluate the operational needs first—what needs to be fast, what needs to be searched, and what needs to be sorted—and design around that.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

Working on this project improved the way I organize code by encouraging modular design, clear internal documentation, and defined responsibilities for each function. I now focus on writing code that is easier to update, easier for others to understand, and flexible enough to adapt to new requirements or larger data sets.
